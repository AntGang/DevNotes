# 数据和信息

- 数据：描述现实世界中的各种事物的可以识别的符号
- 信息：被加工为特定形式的数据

数据是信息的载体，是信息的具体表现形式。数据只有被加工从成信息，才具有使用价值



# 事务

`TRANSACTION`

事务指的是满足ACID特性的**一组操作**

- 一个数据库事务通常包含了一个序列的对数据库的读写操作
- 回滚可以用**回滚日志**（Undo Log）来实现
  - 回滚日志记录着事务所执行的修改操作，在回滚时**反向执行这些修改操作**即可

> **事务本质上是为了应用层服务的**，而不是伴随着数据库系统天生就有的
>
> 当应用程序访问数据库的时候，事务能够简化我们的编程模型。不需要我们去考虑各种各样的潜在错误和并发问题（不用去考虑网络异常了，服务器宕机了）

## ACID特性

- 原子性（Atomicity）

  - 事务被视为不可分割的最小单元，事务中的全部操作在数据库中是不可分割的（要么全部执行，要么全部不执行）

  > 要么提交，要么回滚

- 一致性（Consistency）

  - 数据库在**事务执行前后**都保持一致性状态
  - 在一致性状态下，所有事务对同一个数据行的读取结果都是相同的
  - 几个并行执行的事务，其执行结果必须与**按某一顺序串行执行的结果相一致**

- 隔离性（Isolation）

  - 事务的执行不受其他事务的干扰，事务执行的**中间结果对其他事务必须是透明的**
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的

- 持久性（Durability）

  - 对于任意已提交事务，其所做的修改将会永远保存到数据库中
    - 即使系统发生崩溃，**事务执行的结果也不能丢失**
  - 系统发生崩溃可以用**重做日志**（Redo Log）进行恢复，从而实现持久性
    - 与回滚日志记录数据的逻辑修改不同，Redo Log记录的是数据页的物理修改

> ensuring the consistency is the responsibility of user, not DBMS.", "DBMS assumes that consistency holds for each transaction
>
> - ACID里的AID都是数据库的特征，也就是依赖数据库的具体实现而一致性，实际上它依赖于应用层，也就是依赖于开发者
>
> 保证事务只能把数据库从一个有效（正确）的状态**转移**到另一个有效（正确）的状态
>
> - 数据库的有效(正确）的状态：指满足给这个数据库predefined的一些规则的状态都是valid的



## 特性关系

ACID这几个特性不是一种平级关系

- 只有满足一致性，事务的执行结果才是正确的
- 在无并发的情况下，事务串行执行，隔离性一定能够满足
  - 此时只要能满足原子性，就一定能满足一致性
- 在并发的情况下，多个事务并行执行
  - 事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
- 事务满足持久化特性是为了能应对系统崩溃的情况

> C最重要，可以视为一种要求

## AUTOCOMMIT

MySQL默认采用自动提交模式

- 如果不使用`START TRANSACTION`语句来显式开启一个事务，那么**每个查询操作都会被当做一个事务**并自动提交



# 并发一致性问题

- 在并发环境下，事务的隔离性很难保证，因此会出现很多**并发一致性问题**
  - 产生并发不一致性问题的主要原因是破坏了**事务的隔离性**

通过**并发控制**来保证隔离性

- **并发控制可以通过封锁来实现**
  - 封锁操作需要用户自己控制，相当复杂
- DBMS提供了**事务的隔离级别**
  - 让用户以一种更轻松的方式处理并发一致性问题

## 丢失修改

覆盖

- 一个事务的更新操作被另外一个事务的更新操作覆盖

## 脏读

在不同的事务下，当前事务可以**读取到其他事务未提交的数据**

- 如果其他事务回滚提交的数据，则读取的就是错误数据

## 不可重复读

在一个事务内多次读取同一数据集合，在这一**事务还未结束前**，另一事务也访问了该同一数据集合并修改了数据

- 事务的两次读取的数据可能不一致

## 幻读

一个事务读取某个范围的数据，另一个事务在这个范围内**更新了数据**

- 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同

> 本质上也属于不可重复读的情况
>
> 不可重复读的重点是修改，幻读的重点在于新增或者删除
>
> - 即不可重复读可能发生在`update`,`delete`操作中，而幻读发生在`insert`操作中

# 封锁

- MySQL中提供了两种封锁粒度
  - **行**级锁（`row`）
  - **表**级锁（`table`）

- 应该**尽量只锁定需要修改的那部分数据**，而不是所有的资源
  - 锁定的数据量越少，发生锁争用的可能就越小，**系统的并发程度就越高**

- 加锁需要消耗资源，锁的各种操作（获取锁、释放锁以及检查锁状态）都会增加系统开销
  - 锁定的数据量越少，系统开销就越大

> 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡

## 封锁类型

### 读写锁

- 互斥锁（`Exclusive`），X锁，写锁
- 共享锁（`Shared`），S锁，读锁

**规则**

- 一个事务对数据对象A加了写锁（X），就可以对A进行读取和更新

  - 加锁期间**其它事务不能对A加任何锁**

- 一个事务对数据对象A加了读锁（S），可以对A进行读取操作，但是**不能进行更新操作**

  - 加锁期间**其它事务能对A加S锁，但是不能加X锁**

  > 加了读锁，自己也不可以更新数据

|       | X    | Y    |
| ----- | ---- | ---- |
| **X** | 0    | 0    |
| **Y** | 0    | 1    |

### 意向锁

意向锁（Intention Locks）在原来的X / S锁之上引入了IX / IS锁，**IX/IS都是表锁**，用来表示一个事务想要在**表中的某个数据行**上加X锁或S锁

> 引入原因
>
> - 在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其它事务对表A或者表A中的任意一行加了锁，那么就**需要对表A的每一行都检测一次**，**非常耗时**
> - 通过查看表的意向锁，来避免查询表中每一行数据的锁，节省时间

- 通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其它事务对表A加了X / IX / S / IS锁
  - 如果加了就**表示有其它事务正在使用这个表或者表中某一行**的锁，因此事务T加X锁失败
- 任意IS / IX锁之间都是兼容的，因为它们只**表示想要对表加锁，而不是真正加锁**
- 表级的IX锁和行级的X锁是兼容的，两个事务T1,T2可以分别对两个数据行加X锁
  - 事务T1想要对数据行R1加X锁，事务T2想要对同一个表的数据行R2加X锁，两个事务都需要对该表加IX锁，而IX锁是兼容的，IX锁与行级的X锁也是兼容的，所以两个事务都能加锁成功，**从而对同一个表中的两个数据行做修改**

**规则**

- 一个事务在获得某个**数据行对象**的S锁之前，必须先获得表的IS锁或者更强的锁
- 一个事务在获得某个**数据行对象**的X锁之前，必须先获得表的IX锁

> 意向锁可以更容易地支持多粒度封锁

|        | **X** | **IX** | **S** | **IS** |
| ------ | ----- | ------ | ----- | ------ |
| **X**  | 0     | 0      | 0     | 0      |
| **IX** | 0     | 1      | 0     | 1      |
| **S**  | 0     | 0      | 1     | 1      |
| **IS** | 0     | 1      | 1     | 1      |

## 封锁协议

### 三级封锁协议

- 一级封锁协议的关注点是事务修改的数据

- 二级和三级封锁协议的关注点是事务读取的数据

#### 一级封锁协议

**事务T要修改数据A时必须加X锁，直到事务T结束（提交或者回滚）才释放X锁**

- 可以解决丢失修改（覆盖）问题
  - 因为不能同时有两个事务对同一个数据进行修改，所以事务的修改就不会被覆盖
- 不能解决脏读和不可重复读

#### 二级封锁协议

在一级封锁的基础上，要求**读取数据A时必须加S锁，读取完后才能释放S锁**

- 可以解决读脏数据问题
  - 因为事务在对数据A进行修改时根据一级封锁协议会加X锁，那么其他事务就不能再加S锁了，也就不会读入数据
- 不能解决不可重复读
  - 因为读完数据后即可释放S锁（而事务不一定结束），所以不能保证可重复读

#### 三级封锁协议

在一级封锁的基础上，要求**读取数据A时必须加S锁，直到事务结束了才能释放S锁**

- 可以解决不可重复读的问题
  - 因为读数据A时加上了S锁，其它事务不能对A加X锁，从而避免了在读数据的期间数据改变

### 两段锁协议

- 加锁和解锁分为两个阶段进行

- 可串行化调度
  - 通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同
  - 串行执行的事务互不干扰，不会出现并发一致性问题

- 事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件
  - 满足两段协议可串行化调度，但是可串行化调度不一定满足两段协议

## MySQL隐/显式锁定

MySQL的InnoDB存储引擎采用两段锁协议

- **会根据隔离级别在需要的时候自动加锁**
  - 所有的锁都是在同一时刻被释放，这被称为**隐式锁定**
- InnoDB也可以使用特定的语句进行**显示锁定**

# 隔离级别

## 读取未提交

`READ UNCOMMITTED`

- 最低的隔离级别
- 事务中的修改即使没有提交，对其它事务也是可见的
  - 允许其他事务读取未提交的修改
- 可能会导致脏读，幻读或不可重复读

## 读取已提交

`READ COMMITTED`

- 一个事务只能读取已经提交的事务所做的修改，即一个事务所做的修改在提交之前对其它事务是不可见的
- 可以防止脏读
- 但是有可能会导致不可重复读或幻读

## 可重复读

`REPEATABLE READ`

- 保证在同一个事务中多次读取同一数据的结果是一样的
- 可以防止脏读和不可重复读
- 但是有可能会导致幻读

> 可重复读是指对于**其他事务操作的数据**，多次读取的结果都是一样的，重点在于其他事务的数据。如果第一次读取能够读取到其他事务的数据，后面不管其他事务有任何其他任何操作，都不会影响已读取到的其他事务产生的数据
>
> 但是自身所在的事务中产生的数据，自己是都可以读取到的

## 可串行化

`SERIALIZABLE`

- 最高隔离级别

- 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题


- 要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行
- 可以防止脏读，不可重复读和幻读



# 多版本并发控制

`Multi-Version Concurrency Control` 

MVCC是MySQL的InnoDB存储引擎**实现隔离级别的一种具体方式**

- 用于实现**读取已提交**和**可重复读**这两种隔离级别

> **读取未提交**总是读取最新的数据行，要求很低，无需使用MVCC
>
> **可串行化**需要对所有读取的行都加锁，单纯使用MVCC无法实现



## 基本思想

- MVCC利用了**多版本**的思想（快照）

  - 写操作更新最新的版本快照
  - 读操作去读旧版本快照

  > 没有互斥关系，和`CopyOnWrite`类似
  >
  > 加锁中读写锁中读和写操作则是互斥的

- 在MVCC中事务的修改操作（`DELETE`，`INSERT`，`UPDATE`）会**为数据行新增一个版本快照**

- 在事务进行读取操作时，**MVCC规定事务只能读取已经提交的快照**（从而解决脏读和不可重复读问题）

  - 但可以读取自身未提交的快照

## 版本号

- 系统版本号：`SYS_ID`
  - 每开始一个新的事务，系统版本号就会自动递增

- 事务版本号：`TRX_ID` 
  - 事务开始时的系统版本号

## 快照和Undo Log

- MVCC的多版本（Multi-Version）指的是多个版本的**快照**
- 快照中会记录
  - 事务版本号：`TRX_ID` 
  - 事务操作
  - `DEL`字段（1 bit）：用于标记该数据行是否被删除

- 快照存储在回滚日志Undo Log中，Undo Log通过回滚指针`ROLL_PTR`把一个数据行的所有快照连接起来
- 每当一个事务对某一行或多行数据进行事务更新或删除时
  - 会将当前数据行操作的快照存储到Undo Log
    - 如果是删除操作，还要将`DEL`字段值设置为 1（读取时若`DEL`为1则不返回）
  - 然后更新新数据行的事务版本号：`TRX_ID` 
  - 再将回滚指针`ROLL_PTR`指向Undo Log中的上一个快照

> `DELETE`可以看成是一个特殊的`UPDATE`，会额外将`DEL`字段值设置为 1

## ReadView

MVCC在事务读取时会维护一个ReadView结构，主要包含了

- 当前系统未提交的事务列表：`TRX_IDs {TRX_ID_1, TRX_ID_2...}`

- 低水位：该列表中的最小事务版本号（TRX_ID_MIN）

- 高水位：该列表中的最大事务版本号+1（TRX_ID_MAX+1）

 ![readview](数据库系统原理.assets/readview.png)



在生成readview后，数据库从最新版本的事务开始查询

- 如果该事务id = 创建该readview的事务id（4）
  - 说明是自己查自己，所以对应状态可以被查看

- 如果该事务id < 未提交事务集合中的最小的事务id
  - 说明该行对应的事务是已经提交过的事务，可以查看该行

- 如果该事务id >= 应该分配的下一个事务的id，
  - 说明该行对应的事务在创建readview时还未发生，则对应状态不可以被其他事务查看
- 如果该事务id >= 未提交事务集合中的最小的事务id且该事务id < 未提交事务集合中最大事务id
  - 如果该事务id在未提交事务集合中出现
    - 说明该行对应的事务还未被提交，则对应状态不可以被查看
  - 如果该事务id没有在未提交事务集合中出现
    - 说明该行对应的事务已经被提交，则对应状态可以被查看

readview会因为隔离级别不同有所区别

- 如果在读取已提交级别，每次读都需要根据数据库当前状态更新此时的readview

- 如果在可重复读级别，readview从事务第一次读到事务结束是不会变的，事务从第一次读开始就确定了readview。

这也解释了为什么两个隔离级别一个可以解决不可重复读问题，另一个不行

- 如果该行不可见就依次顺着z指针找旧版本，直到对用户可见为止
- 当然光靠mvcc是无法解决当前读下的幻读问题的，因此需要配合next-key lock来解决幻读问题（但是mvcc可以解决快照读下的幻读问题）

