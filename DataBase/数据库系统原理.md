# 数据和信息

- 数据：描述现实世界中的各种事物的可以识别的符号
- 信息：一种已经被加工为特定形式的数据

数据是信息的载体，是信息的具体表现形式。数据只有被加工从成信息，才具有使用价值



# 事务

`TRANSACTION`

事务指的是满足ACID特性的一组操作

- 一个数据库事务通常包含了一个序列的对数据库的读，写操作
- 回滚可以用回滚日志（Undo Log）来实现
  - 回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可

## ACID特性

- 原子性（Atomicity）
  - 事务被视为不可分割的最小单元，事务中的全部操作在数据库中是不可分割的（要么全部执行，要么全部不执行）
- 一致性（Consistency）
  - 几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致
  - 在一致性状态下，所有事务对同一个数据的读取结果都是相同的
- 隔离性（Isolation）
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的
  - 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的
- 持久性（Durability）
  - 对于任意已提交事务，其所做的修改将会永远保存到数据库中
  - 即使系统发生崩溃，事务执行的结果也不能丢失
  - 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性
    - 与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改

## 特性关系

这几个特性不是一种平级关系

- 只有满足一致性，事务的执行结果才是正确的
- 在无并发的情况下，事务串行执行，隔离性一定能够满足
  - 此时只要能满足原子性，就一定能满足一致性
- 在并发的情况下，多个事务并行执行
  - 事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
- 事务满足持久化是为了能应对系统崩溃的情况



# 并发一致性问题

- 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题
- 产生并发不一致性问题的主要原因是破坏了**事务的隔离性**
- 解决方法：通过并发控制来保证隔离性
  - 并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂
  - 数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题

## 丢失修改

覆盖

- 一个事务的更新操作被另外一个事务的更新操作替换

## 读脏数据

在不同的事务下，当前事务可以读到另外事务未提交的数据

- 如果另外一个事务回滚，则读取的就是错误数据

## 不可重复读

在一个事务内多次读取同一数据集合，在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改

- 事务的两次读取的数据可能不一致

### 幻影读

本质上也属于不可重复读的情况

一个事务读取某个范围的数据，另一个事务在这个范围内更新了数据

- 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同



# 封锁

- MySQL中提供了两种封锁粒度
  - 行级锁
  - 表级锁

- 应该尽量只锁定需要修改的那部分数据，而不是所有的资源
  - 锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高

- 加锁需要消耗资源，锁的各种操作（获取锁、释放锁以及检查锁状态）都会增加系统开销
  - 封锁粒度越小，系统开销就越大

> 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡

