# 微服务架构

Microservice Architecture

- 微服务架构是一种架构模式，或者说是一种架构风格

- 微服务架构将传统的一站式应用根据业务拆分成一个一个的微服务（解耦），每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，服务之间采用轻量级的通信机制（HTTP）互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中

> 应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具（Maven）对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储

## 微服务

强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用

狭义的看，可以看作是IDEA中的Maven项目的一个个Module

## 核心问题

微服务架构的4个核心问题

- 客户端如何访问多服务（API GateWay）
- 多服务之间如何通信（Http，RPC）
  - 通信成本问题
- 如何治理多服务（注册与发现）
- 服务崩了怎么办（熔断机制）

> 多服务运维难度
>
> - 随着服务的增加，运维的压力也在增大

## 解决方法

常见的解决方案

- Spring Cloud NetFlix：一站式解决方案
  - API网关：zuul
  - 通信：Feign（Http通信，同步，阻塞）
  - 服务注册发现：Eureka
  - 熔断机制：Hystrix
- Apache Dubbo Zookeeper：半自动，整合其他组件
  - API网关：没有
  - 通信：Dubbo（RPC）
  - 服务注册发现：Zookeeper
  - 熔断机制：没有，借助其他组件
- Spring Cloud Alibaba：新的一站式解决方案

## 服务网格

Service Mesh

- Istio

服务间通信的基础设施层

Service Mesh负责通过包含现代云原生应用程序的复杂服务拓扑来可靠地传递请求

实际上，服务网格通常通过一组轻量级网络代理来实现，这些代理与应用程序代码一起部署，而不需要感知应用程序本身

可以将Service Mesh比作是应用程序或者说微服务间的TCP/IP，负责服务之间的网络调用、限流、熔断和监控

对于编写应用程序来说一般无须关心TCP/IP这一层（比如通过HTTP协议的RESTful应用），同样使用服务网格也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud，现在只要交给服务网格就可以了

> 服务网格作为sidecar运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现
>
> 服务网格并没有带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在云原生的 Kubernetes环境下的实现
>
> Netflix开发的Hystrix库就是早期的服务网格，但是它们都只适用于特定的环境和特定的开发语言，并不能作为平台级的服务网格支持



### 工作流程

服务网格（Istio）如何在Kubernetes中工作

1. Istio将服务请求**路由到目的地址**，根据请求中的参数判断
   1. 是到生产环境、测试环境还是staging环境中的服务（服务可能同时部署在这三个环境中）
   2. 是路由到本地环境还是公有云环境
   3. 所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置
2. 当Istio确认了目的地址后，将流量发送到相应服务发现端点，在Kubernetes中是 service，然后service会将服务转发给后端的实例
3. Istio根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例
4. Istio将请求发送给该实例，同时记录响应类型和延迟数据
5. 如果该实例挂了、不响应了或者进程不工作了，Istio将把请求发送到其他实例上重试
6. 如果该实例持续返回 error，Istio会将该实例从负载均衡池中移除，稍后再周期性得重试
7. 如果请求的截止时间已过，Istio主动失败该请求，而不是再次尝试添加负载
8. Istio以metric和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中metric系统

# Spring Cloud

**Spring Cloud是一系列框架的有序集合**

Spring Cloud利用Spring Boot的开发便利性**简化了分布式系统基础设施的开发**，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署

Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的**服务框架组合起来**，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包

> 解决微服务架构问题一个**解决方案**，是一种**生态**

## SpringCloud和SpringBoot的关系

- SpringBoot专注于快速、方便的开发单个个体微服务
- SpringCloud关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现注册、断路器、负载均衡、事件总栈、全局锁、决策竞选、分布式会话等集成服务
- SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系

## 技术栈

| **微服务技术条目** | 落地技术                              |
| ------------------ | ------------------------------------- |
| 服务开发           | SpringBoot、Spring、SpringMVC等       |
| 服务配置与管理     | Archaius、Diamond等                   |
| 服务注册与发现     | Eureka、Consul、Zookeeper等           |
| 服务调用           | Rest、PRC、gRPC                       |
| 服务熔断器         | Hystrix、Envoy等                      |
| 负载均衡           | Ribbon、Nginx等                       |
| 服务接口调用       | Fegin等                               |
| 消息队列           | Kafka、RabbitMQ、ActiveMQ等           |
| 服务配置中心管理   | SpringCloudConfig、Chef等             |
| 服务路由(API网关)  | Zuul等                                |
| 服务监控           | Zabbix、Nagios、Metrics、Specatator等 |
| 全链路追踪         | Zipkin、Brave、Dapper等               |
| 数据流操作开发包   | SpringCloud Stream                    |
| 时间消息总栈       | SpringCloud Bus                       |
| 服务部署           | Docker、OpenStack、Kubernetes等       |



