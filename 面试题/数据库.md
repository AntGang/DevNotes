**为什么数据库不用二叉平衡树，红黑树，b树**

1. 二叉平衡树:插入删除效率低，维护的耗费远大于带来的收益
2. 红黑树：虽然相对平衡，但是深度较深，io次数过多，影响效率
3. b树：每个节点可以存很多个索引，也可以存数据，但是对区间查询效果不好，还得回溯，并且每个节点的访问耗费不一致
4. b+树，非叶子节点只存储索引，叶子节点存储数据，每个数据的访问效率一致，且因为叶子间是链表结构，因此支持范围查询



**聚簇索引，非聚簇索引，hash索引的区别**

聚簇索引，是innodb采取的索引结构，以数据库表的主键为key（数据库数据物理磁盘是连续存放的，如果按key递增，就可以实现索引的数据连续存放），每个叶子节点存放data。非主键索引均为非聚簇索引，叶子节点的值均为主键，查询到主键再回到聚簇索引查询行，称为回表查询

非聚簇索引是myisam采取的索引结构，每个叶子节点存放地址

hash索引，把每一列的值进行hash，不适合范围查询模糊查询，适合单列查询

**最左匹配原则**

从左至右，匹配，遇到范围查询或模糊查询就停止，必须按照顺序依次来，不然不走索引

**数据库ACID**

事务是对数据库一系列操作的集合，这些集合满足要么全部发生，要么全部不发生

ACID：

1. 原子性:事务要么全部提交，要么全部回滚
2. 一致性：事务发生前后数据库的一致性不可以受到破坏
3. 隔离性：各个事务间的操作相互不能影响
4. 持久性：事务完成后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

**数据库隔离级别**

1. 读未提交：

   当一个连接开启事务A，更改了数据，在未提交前另一个事务B就可以读取到，如果此时A回滚，B得到的数据就是脏数据，就是脏读。

2. 读提交

   当一个连接开启事务A，更改了数据，在事务A未提交前事务B无法读取到更新后的数据，但是提交后事务B可以读取到更新后的数据，但是如果事务B在一次事务中，在A提交前后都读取一次数据，会发现两次数据不一致，叫做不可重复读。读提交解决了脏读，但不能解决不可重复读。

3. 可重复读

   当一个连接开启事务A，update或delete了一个数据，无论提交与否，事务B都读取不了更新后的数据，但是如果事务A插入一条数据，事务B会在提交前后发现数据多出一条，就是幻读。解决了脏读和可重复读，解决不了幻读

4. 串行化

   对每个事务加锁，让事务串行执行，完全消除上述问题

**MVCC机制**

多版本并发控制，可以让数据读取历史快照来解决读写冲突

每一行数据后都有隐藏列，有最新一次对该行进行修改操作的事务id（事务id随着事务的出现不断增长），有回滚指针（指向undolog)，有删除标记位（标记该行是否是要删除的行）

每次一个事务对某一行或某几行进行事务更新或删除时，都会将当前数据行记录进undolog，然后更新新数据行的事务id，将回滚指针指向上一个undolog（记录前一个状态的数据行，类似链表结构），如果是删除，还要加上删除标记位（读取时看到删除标记位为1则不返回）。

事务在读取时会生成一个readview，readview由四部分组成，第一部分是此时数据库中未提交事务id的集合，第二部分是未提交事务集合的最小事务id，第三部分是数据库应该分配的下一个事务id，第四部分是创建该readview的事务id

生成readview后，从最新版本的事务开始查询

如果该事务id=创建该readview的事务id，证明是自己看自己，所以该状态可以被用户读取到。

如果该事务id小于最小事务id，证明是该行对应的事务是已经提交过的事务id，可以查看

如果该事务id大于等于应该分配的下一个事务的id，证明该行对应的事务在创建readview时还未发生，则状态不可以被查看

如果事务id大于等于最小事务id小于最大事务id，并且在集合中出现，证明该行对应的事务是还未被提交的事务，因此不可以被查看，如果不在集合中出现，说明是该行对应的事务已经被提交，可以查看。

当然生成readview会因为隔离级别不同有所区别，如果在读提交级别，每次读都需要根据数据库当前状态更新此时的readview，而在可重复读级别，readview从事务第一次读到事务结束是不会变的，换句话说就是事务从第一次读开始就确定了readview。也可以解释为什么两个隔离级别一个可以解决不可重复读问题，另一个不行。

如果该行不可见就依次顺着指针找旧版本，直到对用户可见为止

当然光靠mvcc是无法解决当前读下的幻读问题的，因此需要配合next-key lock来解决幻读问题（但是mvcc可以解决快照读下的幻读问题）

**什么时候需要加索引**

1. 在经常被查询的列上加索引
2. 在关联查询的关联列上加索引
3. 在条件列上加索引
4. 在需要排序的列上加索引

**innodb和myisam的区别**

1. innodb支持事务，myisam不支持
2. MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用
3. innodb支持外键，myisam不支持
4. innodb需要扫描表来计算有多少行，myisam不需要
5. 对于自增长字段，innodb必须包含只含有该列的索引，myisam可以和其他一起组成联合索引
6. innodb支持行锁，myisam不支持