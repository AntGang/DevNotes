# 字节码

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件）

- 它不面向任何特定的处理器，只面向虚拟机
- Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点

**运行过程**

1. `.java`文件通过javac编译成`.class`文件
2. `.class`文件通过解释器和JIT编译成机器码

![编辑字节码文件](JVM.assets/编辑字节码文件.png)

## 编译与解释

高级编程语言按照**程序的执行方式**分为两种

- **编译型语言**
  - 通过编译器将源代码**一次性翻译成可被该平台执行的机器码**
  - 一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等
- **解释型语言** 
  - 通过**解释器一句一句的将代码解释（interpret）为机器代码后再执行**
  - 解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有Python、JavaScript、PHP 等

**编译与解释共存**

- 首先由Java编译器将源程序编译成`.class`字节码文件

- JVM类加载器加载字节码文件，然后通过解释器**逐行**解释执行，这种方式比较慢

- 并且有些方法和代码块是经常需要被调用的（所谓的热点代码）

- 所以引进了 JIT（just-in-time compilation） 编译器优化

  - JIT属于运行时编译

  - 当JIT编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用

> HotSpot：采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码）
>
> 这也就是JIT所需要编译的部分
>
> 由于java对于多种不同的操作系统有不同的JVM，所以 Java实现了真正意义上的跨平台

![JIT即时编译](JVM.assets/JIT即时编译.png)

# 内存区域

运行时数据区

- **程序计数器PC**（Program Counter Register）

  - 线程私有
  - 线程切换时能正确恢复

- **虚拟机栈**（Java Virtual Machine Stack）

  - 线程私有
  - 每个方法被执行时，JVM都会创建一个栈帧
  - 栈种的局部变量表存放编译时可知的**基本数据类型，对象引用**
    - 数据类型在表中的存储空间表示为局部变量槽
    - 所需要的内存空间在编译时确定，方法运行期间不会改变大小

- **本地方法栈**（Native Method Stack）

  - 为本地方法服务

- **堆**（Java Heap）

  - JVM管理的内存区域的最大的一块内存
  - 被所有线程共享
  - 几乎所有**对象实例和数组**都存放在堆中（在堆上为其分配内存）
    - 有的对象在栈上分配
  - 垃圾回收器管理的内存区域，也称为GC堆
  - 堆可以划分出多个线程私有的分配缓冲区
    - TLAB：Thread Local Allocation Buffer
    - 为了更好的回收，以及更快的分配内存
  - 堆可以处于物理上不连续的内存空间，但逻辑上应该被视为连续的

- **方法区**（Method Area）

  - 所有线程共享
  - 存储被JVM加载的类型信息，常量，静态变量

  > HotSpot虚拟机在JDK8之前使用**永久代**来实现方法区
  >
  > - 为了让GC可以像管理堆一样管理方法区

- **运行时常量池**

  - 位于方法区中
  - `.class`文件中有一项常量池表（Constant Pool Table），存放编译时生成的各种字面量和符号引用，在类加载后存放在方法区中的运行时常量池中
  - 不同于`.class`文件中的常量池表，运行时常量池具有动态性
    - 运行期间可以将新的常量放入池中

- **直接内存**（Direct Memory）

  - 不是JVM中定义的内存区域，也不是JVM运行时数据区的一部分
    - 受本机内存和处理器寻址空间限制
  - JDK1.4引入了NIO（`New Input/Ouput`）类，引入了基于通道（Channel）和缓冲区（Buffer）的I/O方式。使用`Native`函数直接分配**堆外内存**，然后通过存储在堆中的DirectByteBuffer对象作为这块**内存的引用**进行操作



# 对象

HotSpot虚拟机在Java堆中操作对象

## 对象的创建

`new`+普通Java对象

> 还有复制，反序列化，还有数组和class对象

![对象创建过程](JVM.assets/对象创建过程.png)

## 对象的内存布局

## 对象的访问定位

