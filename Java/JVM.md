# 字节码

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件）

- 它不面向任何特定的处理器，只面向虚拟机
- Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点

**运行过程**

1. `.java`文件通过javac编译成`.class`文件
2. `.class`文件通过解释器和JIT编译成机器码

![编辑字节码文件](JVM.assets/编辑字节码文件.png)

## 编译与解释

高级编程语言按照**程序的执行方式**分为两种

- **编译型语言**
  - 通过编译器将源代码**一次性翻译成可被该平台执行的机器码**
  - 一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等
- **解释型语言** 
  - 通过**解释器一句一句的将代码解释（interpret）为机器代码后再执行**
  - 解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有Python、JavaScript、PHP 等

**编译与解释共存**

- 首先由Java编译器将源程序编译成`.class`字节码文件

- JVM类加载器加载字节码文件，然后通过解释器**逐行**解释执行，这种方式比较慢

- 并且有些方法和代码块是经常需要被调用的（所谓的热点代码）

- 所以引进了 JIT（just-in-time compilation） 编译器优化

  - JIT属于运行时编译

  - 当JIT编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用

> HotSpot：采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码）
>
> 这也就是JIT所需要编译的部分
>
> 由于java对于多种不同的操作系统有不同的JVM，所以 Java实现了真正意义上的跨平台

![JIT即时编译](JVM.assets/JIT即时编译.png)

# 内存区域

运行时数据区

- **程序计数器PC**（Program Counter Register）

  - 线程私有
  - 线程切换时能正确恢复

- **虚拟机栈**（Java Virtual Machine Stack）

  - 线程私有
  - 每个方法被执行时，JVM都会创建一个栈帧
  - 栈种的局部变量表存放编译时可知的**基本数据类型，对象引用**
    - 数据类型在表中的存储空间表示为局部变量槽
    - 所需要的内存空间在编译时确定，方法运行期间不会改变大小

- **本地方法栈**（Native Method Stack）

  - 为本地方法服务

- **堆**（Java Heap）

  - JVM管理的内存区域的最大的一块内存
  - 被所有线程共享
  - 几乎所有**对象实例和数组**都存放在堆中（在堆上为其分配内存）
    - 有的对象在栈上分配
  - 垃圾收集器管理的内存区域，也称为GC堆
  - 堆可以划分出多个线程私有的分配缓冲区
    - TLAB：Thread Local Allocation Buffer
    - 为了更好的回收，以及更快的分配内存
  - 堆可以处于物理上不连续的内存空间，但逻辑上应该被视为连续的

- **方法区**（Method Area）

  - 所有线程共享
  - 存储被JVM加载的类型信息，常量，静态变量

  > HotSpot虚拟机在JDK8之前使用**永久代**来实现方法区
  >
  > - 为了让GC可以像管理堆一样管理方法区

- **运行时常量池**

  - 位于方法区中
  - `.class`文件中有一项常量池表（Constant Pool Table），存放编译时生成的各种字面量和符号引用，在类加载后存放在方法区中的运行时常量池中
  - 不同于`.class`文件中的常量池表，运行时常量池具有动态性
    - 运行期间可以将新的常量放入池中

- **直接内存**（Direct Memory）

  - 不是JVM中定义的内存区域，也不是JVM运行时数据区的一部分
    - 受本机内存和处理器寻址空间限制
  - JDK1.4引入了NIO（`New Input/Ouput`）类，引入了基于通道（Channel）和缓冲区（Buffer）的I/O方式。使用`Native`函数直接分配**堆外内存**，然后通过存储在堆中的DirectByteBuffer对象作为这块**内存的引用**进行操作



# 对象

HotSpot虚拟机在Java堆中操作对象

## 对象的创建

`new`+普通Java对象

> 还有复制，反序列化，还有数组和class对象

1. JVM检查指令参数能否在常量池中定位到一个类的符号引用，并且进行类加载检查

   1. 检查符号引用代表的类是否已经被加载，解析和初始化
   2. 如果没有，则需要先执行相应的类加载过程

2. JVM为对象分配内存，分配空间大小在类加载完成后就可以确定。JVM从Java堆中划分一块区域，划分方法取决于**堆内存的规整性**，堆内存的规整性由使用的**垃圾收集器是否能进行空间压缩整理**所决定的

   1. 堆内存规整：采用**指针碰撞**（Bump The Pointer）的分配方式
      1. 使用过的内存和未使用的内存之间用一个指针作为分界指示器
      2. 分配内存只需要将指针向空闲内存方向挪动对象大小的距离
   2. 堆内存不规整：采用**空闲列表**（Free List）的分配方式
      1. 使用过的内存和未使用的内存交织在一起，需要维护一个列表来记录未使用的内存块
      2. 从列表上找到一个足够大的空间分配给对象实例，然后更新表

3. 并发场景下的内存分配（线程不安全）

   > 可能在给对象A分配内存的时候，给对象B同时分配内存，并且使用了同一个指针

   1. **本地线程分配缓冲**（TLAB：Thread Local Allocation Buffer）
      1. 将内存分配的动作根据线程划分在不同空间之间进行
      2. 给每个线程预先在堆内存中分配一块区域，即TLAB，线程分配内存时，就在TLAB中分配，TLAB用完后才使用同步锁定在堆中分配

4. JVM将分配的内存空间**初始化为零值**

   1. 如果有TLAB，则可以提前到TLAB分配时初始化
   2. 保证对象实例在代码中不赋初始值也可以直接使用

5. JVM设置对象信息，存放在**对象头**（Object Header）中

   1. 对象是哪个类的实例
   2. 对象的hashcode值
   3. 对象的GC分代年龄

6. 按照代码的意愿初始化对象，构造出一个真正可用的对象实例

   1. 执行`.class`文件的`<init>()`方法

![对象创建过程](JVM.assets/对象创建过程.png)

## 对象的内存布局

对象在堆内存中的存储布局

- **对象头**（Header）
  - **Mark Word**：存储对象自身的运行时数据
    - hashcode值
    - GC分代年龄
    - 锁状态标志
    - 线程持有的锁
  - **类型指针**：对象指向它的类型元数据的指针
    - JVM通过指针来确定是哪个类的对象实例
- **实例数据**（Instance Data）
  - 对象的有效信息，即代码中定义的字段内容
  - 相同宽度的对象会被放在一起
    - 父类中定义的变量会放在子类之前
- **对齐填充**（Padding）
  - 非必须，HotSpot虚拟机要求对象的起始地址是8字节的整数倍

## 对象的访问定位

Java程序通过栈中的对象引用来操作堆中的对象

JVM决定引用来定位访问对象的实现

- **句柄访问**：Java堆中会划分出一块内存作为**句柄池**
  - 引用中存放对象的句柄地址
  - 句柄中存放**对象实例数据**和**对象类型数据**的具体地址信息
  - 在对象被移动时只需要修改句柄中的实例地址，引用中的句柄地址不变
- **直接指针访问**：需要考虑如果存放**对象类型数据**信息
  - 引用中存放的直接就是对象在堆中的地址
  - 少一次间接访问的开销



# 垃圾收集器

GC：Garbage Collection

- 哪些内存需要回收
- 什么时候回收
- 如何回收

**确定性**

- 程序计数器，虚拟机栈，本地方法栈随线程创建，消亡。栈帧随方法的进入，退出执行出入栈
  - 所以当方法或线程结束时，这些内存就回收了

**不确定性**

- Java堆和方法区
  - 这些内存的回收是动态的

