# JUC并发编程

`java.util.concurrent`

并发执行不一定比串行快，**因为线程创建和上下文切换会有开销**，即多线程不一定快

资源限制：程序的执行速度受限于计算机硬件和软件资源

- 硬件资源：带宽的上传，下载速度，硬盘读写速度，CPU处理速度
- 软件资源：数据库的连接，socket连接数

# volatile

volatile轻量级的synchronized，**在并发中保证共享变量的可见性**

- 比synchronized的使用和执行成本低，因为volatile不会引起线程上下文的切换和调度
- volatile不能保证原子性

## 实现原理

> Java允许线程访问共享变量，为了确保共享变量能够被准确和一致的更新，线程需要确保通过排它锁单独获得这个共享变量

如果一个字段被声明为volatile，Java内存模型会确保所有线程看到的变量值是一样的

### volatile实现原则

volatile修饰的共享变量进行写操作时会多出一条Lock汇编指令，Lock前缀指令在多核处理器中会引发两件事情

1. **将当前处理器缓存行的数据写回到系统内存**
2. **写回到系统内存操作会让其他CPU里缓存改内存地址的数据无效**

> Lock指令会导致在执行指令期间，声言处理器的LOCK#信号，LOCK#信号会把缓存锁住（锁总线开销太大）

CPU不直接与内存通信，而是将内存数据先读到缓存中再进行操作，但不知何时将其写回内存。如果对volatile修饰的共享变量进行了写操作，JVM就会向处理器发送Lock前缀指令，将在缓存行中的数据写回内存

在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致协议**

- 每个处理器通过嗅探在总线上传播数据来检查自己的缓存是否过期
- **如果处理器发现自己缓存行对应的内存地址被修改了，就会将当前的缓存行设置为无效状态**
- 处理器并不会直接修改缓存，而是当处理器需要对这个数据进行修改操作时，重新从内存中读取到缓存中

> 缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据

# Synchronized

重量级锁

## 实现原理

Java中**任何对象都可以作为锁**

- 普通同步方法：锁的是当前实例对象
- 静态同步方法：锁的是当前类的Class对象
- 同步方法块：锁的是Synchronized括号中的对象

当一个线程试图**访问同步代码块时，它必须先获得锁，退出或抛出异常时必须释放锁**

### Synchronized在JVM中的实现

JVM基于进入和退出**Monitor对象**来实现方法和代码块同步

- 代码块同步：**使用monitorenter和monitorexit指令实现**
  - monitorenter指令是在编译后插入到同步代码块的开始位置
  - monitorexit指令则是插入到方法结束处或者异常处
- 方法同步：用另一种方式实现，也可以和代码块同步一样实现

JVM保证每个monitorenter指令后面都要有一个对应的monitorexit指令来配对

**任何对象都有一个moniot相关联**，当且仅当一个monitor被持有后，它将处于锁定状态，线程执行到monitorenter指令时，会尝试获取对象所对应的monitor的所有权，**这就是获取对象的锁**

## Java对象头

Synchronized使用的锁存在Java对象头中

Java对象头

- **Mark Word**
  - 存储对象的hashcode值，分代年龄，锁标志位等
- **Class Metadata Address**
  - 存储到对象类型的指针
- **Array length**
  - 数组的长度

Mark Word

- 锁状态
- 对象的hashcode值
- 对象分代年龄
- 是否是偏向锁
- 锁标志位

其中根据锁标志位，Mark Word存储的数据会发生变化

- 00：轻量级锁
- 10：重量级锁
- 11：GC标记
- 01：偏向锁

JDK1.6为了减少获得锁和释放锁带来的性能消耗，**引入了偏向锁和轻量级锁**

- 锁分为4种状态，**依次是**无锁状态，偏向锁状态，轻量锁状态和重量锁状态
- 4种锁状态会随着竞争逐渐升级，**锁可以升级但不能降级**，这样可以提高获得和释放锁的效率

## 偏向锁

大多数情况，**锁不仅不存在多线程竞争，而且总是由同一线程多次获得**

**偏向锁的获取**

- 当一个线程访问同步代码块并获取锁时，会在**对象头**和**栈帧中的锁记录中**存储锁偏向的线程ID
- 以后该偏向的线程在进出同步代码块时**不需要进行CAS操作来加锁和解锁**，只需要测试对象头的Mark Word里是否存储着指向当前线程的偏向锁
  - 如果测试成功，表示线程已经获得了锁
  - 如果测试失败，再测试Mark Word中偏向锁的标识是否设置为1（表示是偏向锁）
    - 如果没有设置为1，则使用CAS竞争锁
    - **如果设置为1，则尝试用CAS将对象头中的偏向锁指向当前线程**

**偏向锁的释放**

偏向锁不会主动释放，它是等到竞争时才释放锁，**即当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁**，并且偏向锁的释放需要等到**全局安全点**（在这个点上没有正在执行的字节码）

1. 释放偏向锁首先需要**暂停持有偏向锁的线程**，然后检查持有偏向锁的线程是否存活
2. 如果线程不存活，则将对象头设置为**无锁状态**
3. 如果线程依然存活，**持有偏向锁的线程的栈**会被执行，遍历偏向对象的锁记录
   1. 栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程
   2. 要么**恢复到无锁状态**或者**标记该对象不适合作为偏向锁**

>  JDK6和JDK7默认启动偏向锁，如果关闭偏向锁，程序会默认进入轻量锁状态

**偏向锁是乐观锁**

- 在一个对象刚开始实例化，没有任何线程来访问它的时候，它是可偏向的
  - 这意味着它现在认为只可能有一个线程来访问它
  - 所以当第一个线程来访问它的时候，它会偏向这个线程
- 此后对象持有偏向锁，偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID
  - 之后该线程再次访问这个对象时，只需要对比ID，不需要再使用CAS进行操作

- 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象的偏向状态
  - 表明在这个对象上已经存在竞争了
- 该线程会检查原来持有该对象锁的线程是否依然存活
  - 如果原来的线程已经死亡，则可以将对象变为无锁状态，然后重新偏向自己
  - 如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况
    - 如果原来的线程仍然需要持有偏向锁，则该偏向锁升级为轻量级锁（偏向锁就是这个时候升级为轻量级锁的）
    - 如果原来的线程不再使用偏向锁，则可以将对象回复成无锁状态，然后重新偏向

## 轻量级锁

**轻量级锁加锁**

- 线程在执行同步代码块前，JVM会先**在当前线程的栈帧中创建一个用于存储锁记录的空间**
- **将对象头中的Mark Word复制到线程栈帧的锁记录空间中**，成为Displaced Mark Word
- 然后线程会尝试**使用CAS将对象头中的Mark Word替换为指向锁记录的指针**
  - 如果成功，当前线程获得该锁
  - 如果失败，表示其他线程竞争该锁，**尝试使用自旋来获取锁**

**轻量级锁解锁**

- 解锁时使用CAS将Displaced Mark Word替换**回**到对象头中
  - 如果成功，表示没有竞争，释放锁会唤醒等待进程
  - 如果失败，表示其他线程竞争该锁，锁会膨胀成重量级锁

其他锁在竞争锁时会采用自旋，但无用的自旋会消耗CPU（比如获得锁的线程被阻塞了）。而一旦升级成了重量级锁，就不会恢复到轻量级锁状态。重量级锁状态，其他线程试图获得锁失败时都会被阻塞，当持有锁 的线程释放锁后就会唤醒这些阻塞线程，被唤醒的线程就会进行新一轮锁的竞争

**轻量级锁是乐观锁**

轻量级锁认为竞争存在，但是竞争的程度很轻

- 一般两个线程对于同一个锁的操作都会错开
- 或者说稍微等待一下（即自旋），另一个线程就会释放锁
- 如果自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个线程竞争锁时，轻量级锁就会膨胀为重量级锁
  - 重量级锁使除了拥有锁的线程以外的竞争线程都会被阻塞，防止CPU空转

## 锁的区别

**偏向锁**

- 加锁和解锁不需要额外的消耗
- 如果线程间存在锁竞争，会带来额外的释放锁的消耗
- 适用于只有一个线程访问同步场景

**轻量级锁**

- 竞争的线程不会阻塞，提高了程序的响应速度
- 如果使用得不到锁的线程，使用自旋会消耗CPU
- 适用于追求响应时间的场景

**重量级锁**

- 线程竞争不使用自旋，不会消耗CPU
- 线程阻塞，响应时间慢
- 适用于追求吞吐量的场景



# 悲观锁和乐观锁

> “对锁了解吗？谈谈你知道的锁？何为乐观锁？怎样实现？分段锁哪里有体现？这样设计有什么好处？”

## 悲观锁

悲观锁认为**对于同一个数据的并发操作，一定会发生修改的**。**哪怕没有修改，也会认为修改**。因此对于同一份数据的并发操作，**悲观锁采取加锁的形式**。悲观的认为，不加锁并发操作一定会出问题

- 悲观锁适用于**多写场景**



## 乐观锁

乐观锁觉得**并发操作期间是不会出问题的**，**操作数据不加锁**，只会最后更新数据时**检查数据有没有被修改**，没有的话才更新

- 乐观锁 严格来说并不是锁，**通过原子性来保证数据的同步**
- `java.util.concurrent.atomic`包下的**原子类**就是使用CAS实现的
- 乐观锁适用于**多读场景（写比较少）**

### CAS机制

CAS：Compare and swap ，即**比较并交换**

> 自旋锁或乐观锁的核心操作

CAS机制当中使用了3个基本操作数

- 内存地址V
- 旧的预期值A
- 要修改的新值B

线程更新一个变量的时候，只有当**变量的预期值A和内存地址V当中的实际值相同时（比较），才会将内存地址V对应的值修改为B**

如果比较值不相同，则修改失败，线程会重新获取内存地址V的值，并重新计算期望值A，**重新尝试的过程被称为自旋**

> 工作内存会拷贝一份主内存的值，以此来计算期望值
>
> CAS操作是由硬件支持的，现在的处理器基本支持原子化的CAS指令

**缺点**

- CAS可能会造成**ABA问题**
- CPU开销较大，在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力
- 不能保证代码块的原子性，CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性

> 当需要保证3个变量共同进行原子性的更新，就必须使用Synchronized

### ABA问题

当一个值从A被更新为B，然后又改回A，普通的CAS机制发现不了，因为CAS只比较期望值和当前值，不在乎中间状态 

**解决方法**

- 可以为数据添加时间戳，每次成功修改数据时，不仅更新数据的值，同时要更新时间戳的值
- CAS操作时，不仅要比较当前值和预期值，还要比较当前时间戳和预期时间戳。两者都必须满足预期值才能修改成功 
