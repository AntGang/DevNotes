# Java

## native方法

`native`关键字修饰

- 说明这个方法是个原生函数，不是用java语言实现的，是使用c/c++实现的

- 被编译成了DLL，由java去调用，jdk源码中不包含
- 对于不同的平台它们是不同的，java在不同的操作系统中调用不同的`native`方法实现对操作系统的访问，
  - 因为java没有指针，不能直接访问操作系统底层

**调用过程**

1. 在java中声明`native`方法，然后编译
2. 用`javah`产生一个 `.h` 文件
3. 写一个 `.cpp`文件实现`native`方法
   1. 需要包含第二步产生的`.h`文件
   2. 需要包含了jdk带的jni.h文件
4. 将`.cpp`文件编译成动态链接库文件
5. 在java中用`System.loadLibrary()`文件加载动态链接库文件

这个`navite`方法就可被访问了

## 集合

### 重写`hashCode()`和`equals()`

`Collection`接口：对象所在类需要重写`equals()`方法

- `contains(Object obj)`：调用对象所在类的`equals`方法来判断集合中每一个元素是否是目标元素
- `remove(Object obj)` ：调用对象所在类的`equals`方法判断是否是要删除的那个元素，只会删除匹配的第一个元素



`Set`接口：对象所在类要重写`equals()`和`hashCode()`方法，以实现对象相等规则（相等的对象必须具有相等的散列码）

- `Map`中的`key`使用`Set`存储，所以`key`所在类必须重写`hashCode()`和`equals()`方法



**hashcode()**找位置，**equals()**判断位置上的元素

1. `HashSet`调用要添加**对象所在类**的`hashCode()`方法来得到该对象的hashCode值
2. 散列函数根据对象的hashCode值决定它在`HashSet`底层数组中的**存储位置**
   1. 散列函数会利用**底层数组的长度**计算得到对象在数组中的下标
   2. **散列函数计算会尽可能保证能均匀存储**，越是散列分布，该散列函数设计的越好
3. 如果该存储位置上**没有其他对象，则添加该对象**
4. 如果该存储位置上有其他对象，则需要比较两个对象的hashCode值
   1. 如果两个对象的**hashCode值不相等，则通过链表的方式添加该对象**
   2. 如果两个对象的hashCode值相等，再调用`equals()`方法
      1. 如果`equals()`方法结果为`true`，则添加失败
      2. 如果`equals()`方法结果为`false`，**则通过链表的方式添加该对象**

> 以链表的形式在同一个位置上存放多个元素会使得`HashSet`的性能降低，因为不能快速定位了



重写`hashCode()`方法

- 对同一个对象多次调用`hashCode()`方法应该返回相同的值
- 当两个对象的`equals()`方法比较返回true 时，两个对象的`hashCode()`方法的返回值也应相等
- 对象中用作`equals()`方法比较的属性，都应该用来计算hashCode值

> 所以重写了`equals()`方法也要重写`hashCode()`方法
>
> IDEA中在自定义类调用工具自动重写`equals()`和`hashCode()`方法时默认使用31
>
> - 31只占用5bits，相乘造成数据溢出的概率较小
> - 31可以由i*31== (i<<5)-1来表示，现在很多虚拟机里面都有做相关优化（提高算法效率）
> - 31是一个素数，一个数字乘以素数的最终结果只能被素数本身和被乘数还有1来整除（减少冲突）
> - 选择系数的时候要选择尽量大的系数，因为计算出来的hash地址越大，冲突就越少，查找起来效率也会提高





## Java虚拟机

Java内存区域

1. 介绍下Java内存区域（运行时数据区）

2. 对象的访问定位的两种方式

Java内存回收

1. 如何判断对象是否死亡（两种方法）。

2. 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。

3. 垃圾收集有哪些算法，各自的特点？

4. HotSpot为什么要分为新生代和老年代？

5. 常见的垃圾回收器有那些？

6. 介绍一下CMS,G1收集器。

7. Minor Gc和Full GC 有什么不同呢？

类加载机制

1. 简单说说类加载过程，里面执行了哪些操作？

2. 对类加载器有了解吗？

3. 什么是双亲委派模型？

4. 双亲委派模型的工作过程以及使用它的好处。

类文件结构

- 介绍一下Class类文件结构
- 常量池主要存放的是那两大常量？
- Class文件的继承关系是如何确定的？
- 字段表、方法表、属性表主要包含那些信息？

 

## 多线程

### 线程创建

1. 继承`Thread`类
2. 实现`Runnable`接口
3. 实现`Callable`接口

> 重写`run()`方法：**线程体**

**比较**

推荐使用`Runnable`接口

- 避免单继承局限性
- 方便同一个对象被多个线程共享使用
  - 适合多个相同线程来处理同一份资源

### 线程启动

通过`start()`方法启动线程

- Java的线程是不允许启动两次的，一个线程对象只能调用一次`start()`方法启动
  - 重复调用抛出异常（运行时异常）
- 直接调用`run()`无法开启一个新线程
  - `run()`方法只是一个类中的普通方法，直接执行和普通的方法没区别，`start()`方法首先做了创建线程等一系列工作，然后调用`run()`方法
  - 即`start()`方法是在一个新的线程上面去调用`run()`方法，`run()`方法则是在调用`run()`方法的当前的线程当中执行

#### 静态代理

StaticProxy：`new Thread(Runnable).start();`

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实对象

**优点**

- 真实对象专注于自己的工作
- 代理对象可以做真实对象做不了的工作

### 线程状态

1. 创建（`NEW`）
   1. 当一个`Thread`类或其子类的对象被**声明并创建**时，新生的线程对象处于创建状态
   1. 还没有调用`start()`方法
2. 就绪（`RUNNABLE`）
   1. 处于创建状态的线程被`start()`后将进入线程队列等待CPU时间片
   2. 此时它已具备了运行的条件，只是没分配到CPU资源
3. 运行（`RUNNING`）
   1. 当就绪的线程被调度并获得CPU资源时就进入运行状态
   2. `run()`方法定义了线程的操作和功能
4. 阻塞（`BLOCKED`）
   1. 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
5. 死亡（`DEAD`）
   1. 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束
   2. 结束后的线程不能再次启动



### 线程池

`ThreadPool`：并发框架

**优点**

1. 降低资源消耗。 通过重复利用已经创建的线程降低线程创建的和销毁造成的消耗。例如，工作线程Woker会无线循环获取阻塞队列中的任务来执行。
2. 提高响应速度。 当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。 线程是稀缺资源，Java的线程池可以对线程资源进行统一分配、调优和监控。



# 计算机网络

## TCP



# 操作系统

## 用户态和内核态

问题

- **如何限制代码行为**
  - 比如禁止：设置特殊寄存器的值，访问存储器的任意位置，I/O 请求，申请更多系统资源等
- 在运行这个程序的时候，**如何切换到另一个程序**
  - 进程调度应该是OS才有的权限

解决方法

**引入用户态和内核态和两种模式**

- 用户态无法执行受限操作，执行这些操作会引发异常。
- 内核态只能由操作系统运行，可以执行特权操作
- 用户程序通过**系统调用**（system call）执行这些特权操作
  - OS执行前会判断进程是否有**权限**执行相应的指令

**受限直接执行**：Limited Direct Execution

- 区分用户态和内核态的执行机制

### 陷入内核态

**系统调用**（trap）、**中断**（interrupt）**和异常**（exception）都会陷入内核态

- **系统调用是用户进程主动发起的操作**
  - 进程发起系统调用
  - 陷入内核态
  - 由操作系统执行系统调用
  - 再返回到进程

- 中断和异常是被动的，**无法预测发生时机**
  - 中断包括 I/O 中断，外部信号中断，各种定时器引起的时钟中断等
  - 异常包括程序运算引起的各种错误如除0，缓冲区溢出，缺页等

> 在系统的处理上，中断和异常类似，都是**通过中断向量表来找到相应的处理程序进行处理**
>
> - 区别在于**中断来自处理器外部**，不是由任何一条专门的指令造成，而**异常是执行当前指令的结果**
>
> C访问**访问空指针**会陷入内核态
>
> - 访问指针相当于**访问一个虚拟地址**，硬件会将虚拟地址映射到真实的物理内存
> - 如果映射失败，硬件会抛出一个**段错误异常**（`page fault exception`），此时会**从用户态转为内核态**进行处理
>   - OS会在中断向量表中找到处理`page fault exception`的中断向量，执行相应的handler



## 并行与并发

- 并行：parallelism
  - 多个处理器或者多核处理器**同时**处理多个不同的任务
- 并发：concurrency
  - 通过调度算法，一个处理器同时处理多个任务

## 进程和线程

`Process`和`Thread`

- 进程是系统进行**资源分配**的基本单位，线程是**CPU调度**的基本单位
- 线程依赖于进程而存在，一个进程至少有一个线程
- 进程有自己的独立地址空间，**线程共享所属进程的地址空间**
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器PC，寄存器REG和**栈**），和其他线程共享本进程的相关资源（如内存，堆，I/O，CPU等）
- 在进程切换时，涉及到整个**当前进程CPU环境**的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作
  - **进程切换的开销远大于线程切换的开销**
- 线程之间的通信更方便，同一进程下的线程**共享全局变量等数据**，而进程之间的通信需要以进程间通信（IPC）的方式进行
- **多线程程序**只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为**进程有自己的独立地址空间**
  - 多进程更加健壮

> 进程切换开销太大，因此引入线程

### 协程

协程是一种**用户态的轻量级线程**

- 协程的调度完全由用户控制

- **协程拥有自己的寄存器上下文和栈**

  - 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈
  - 直接操作栈基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快
  - 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

- 一个线程可以拥有多个协程，一个进程也可以拥有多个协程

- 线程进程都是同步机制，而协程则是异步

  

## 进程通信

**进程间通信是实现进程同步的手段**

- 共享内存（Shared Memory）
- 消息队列（MQ：Message Queue）
- 管道（Pipe）
- 命名管道
- 信号（Signal）
- 信号量（Semaphore）
- 套接字（Socket）

### 信号

信号是Linux系统**响应某些条件而产生的一个事件**，是一种**更高层的**软件形式的异常，一个信号代表了一个消息

- 信号的作用是用来**通知进程**发生了某种系统事件，是一种**订阅-发布**的模式

- 由操作系统事先定义，接收到该信号的进程可以采取自定义的行为

**信号来源**

- 硬件来源：如按下`CTRL+C`、除0、非法内存访问等
- 软件来源：如`kill`命令、Alarm Clock超时、当Reader中止之后又向管道写数据等

> `kill -9`

**一般的信号是都是由一个错误产生的**

- 除数为0时会引发0号中断，即除零异常，这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT中的中断处理程序

- 操作系统**处理这个异常的方法就是向进程发送一个信号** `SIGFPE`。如果进程设置了相应的signal handler，就执行进程的处理方法。否则就执行操作系统的默认操作（一般这种信号的默认操作是杀死进程）

> 操作系统会**将这些硬件异常包装成信号发送给进程**，如果进程不处理这几个异常信号，默认的行为就是挂掉

**进程发送信号**

- 操作系统提供发送信号的**系统调用**
- 发送信号时，必须指明发送的目标进程的PID
  - 一般用在具有**亲缘关系的进程之间**
- 系统调用会**将信号放到目标进程的信号队列中**
  - 如果目标进程未处于执行状态，则该**信号就由内核保存**起来，直到该进程恢复执行并传递给它为止
  - 如果一个**信号被进程设置为阻塞**，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程

**进程接收信号**

- 每个进程有一个信号队列，存放**其他进程发送给它，等待它处理的信号**
- 进程在执行过程中的**特定时刻检查并处理自己的信号队列**
  - 如从系统空间返回到用户空间之前

**用户进程对信号的处理**

- 处理信号

  - 定义**信号处理函数**，当信号发生时执行相应的处理函数
- 忽略信号

  - 当不希望接收到的信号对进程的执行产生影响时，可以忽略该信号，不对信号进程作任何处理，从而让进程继续执行时
- 不处理也不忽略

  - 执行默认操作，linux系统对每种信号都规定了默认操作
- 有些信号用户进程是无法处理也无法忽略的（如`SIGSTOP`、`SIGKILL` 等）



### 管道

管道是一种**半双工的通信方式**，数据只能**单向流动**

- 上游进程往管道中写入数据，下游进程从管道中接收数据
- 如果想实现双方通信，那么需要建立两个管道

- 管道发送的内容是**没有格式的字节流**，适合于**传输大量信息**

**管道同步**

操作系统会保证**读写进程的同步**

- 管道就相当于一个文件，**同一时刻只能有一个进程访问**
  - 下游进程或者上游进程需要**等另一方释放锁后才能操作管道**。
    - 当管道为空时，下游进程读阻塞
    - 当管道满时，上游进程写阻塞

> 在 Linux Shell 中经常使用管道操作符`|`来表示两个命令之间的数据通信
>
> - 管道操作符`|`的内部实现就是 Linux 的管道接口
> - 由管道操作符`|`分割的**每个命令是独立的进程**，各个进程的标准输出`STDOUT`，会作为下一个进程的标准输入`STDIN`

**创建管道**

Linux管道包含**匿名管道**和**命名管道**，匿名管道只能用在**亲缘进程**中，管道文件信息保存在内存里

- 通过 `pipe()` 系统调用来创建并打开一个**匿名管道**
- 匿名管道只能用于具有**亲缘关系的进程**之间
  - 父子进程或兄弟进程

> 当管道不再被任何进程使用时会自动消失

**实现管道**

- **管道就是一个文件**
  - 一种**只存在于内存中**的特殊的文件系统
- 在Linux中管道借助了**文件系统的File结构**实现
  - 父进程使用File结构保存向管道写入数据的例程地址，子进程保存从管道读出数据的例程地址（单向流动，亲缘进程）
- 管道是由内核管理的一个**环形的数据结构缓冲区**，以便管道可以被循环利用（循环队列）



**命名管道**

`FIFO`

- 命名管道可用于没有亲缘的进程间

- 通过 `mknode()` 系统调用或者 `mkfifo()` 函数创建命名管道
  - 任何有访问权的进程都可以**通过文件名将其打开和进行读写**，而不局限于亲缘进程

- 创建命名管道时会**在磁盘中创建一个索引节点**，命名管道的名字就相当于**索引节点的文件名**
  - 索引节点设置了**进程的访问权限**，但是没有数据块
- 命名管道实质上也是通过**缓冲区**来实现数据传输
  - 有访问权限的进程可以通过磁盘的索引节点来读写这块缓冲区
- 当不再被任何进程使用时命名管道在内存中释放，但磁盘节点仍然存在

### 信号量

信号量是一种特殊的变量，**对它的操作都是原子的**

- 在Linux系统中，二进制信号量又称**互斥锁**（`Mutex`）
  - 可以用于实现进程或线程的互斥和同步

- 信号量在底层的实现是**通过硬件提供的原子指令**（如 `Test And Set`、`Compare And Swap` 等）

> V：`signal()`，P：`wait()`
>
> - `V(S)`：如果有其他进程因等待S而被挂起，就让它恢复运行，否则S加 1
>
> - `P(S)`：如果S<=0，则挂起进程，否则S减1



### 共享内存

允许多个进程共享同一段物理内存

- **不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它**
  - 共享内存区只会驻留在创建它的进程地址空间内。
  - 不同进程可以通过向共享内存端读写数据来交换信息

**优点**

**简单且高效**：访问共享内存区域和访问进程独有的内存区域一样快

- 不需要系统调用，不涉及**用户态到内核态的转换**
  - 只在建立共享内存区域时需要系统调用
  - 建立共享内存后所有访问都可作为**常规内存访问**，无需借助内核
- 不需要对数据不必要的复制

**缺点**

**存在并发问题**：有可能**多个进程同时修改同一块内存**

- 因此共享内存一般与信号量结合使用

> Linux2.2.x内核支持多种共享内存方式
>
> - `mmap()`系统调用
>   - 将**普通文件**映射到进程的地址空间，然后可以像访问普通内存一样对文件进行访问，不必再调用`read()`，`write()`等操作
>   - `mmap()`不是专门用来共享内存的，但是多个进程可以通过`mmap()`映射同一个普通文件来实现共享内存
> - 系统V
>   - 通过**映射特殊文件系统shm中的文件**实现进程间的共享内存
>   - 通过`shmget`可以创建或获得共享内存的标识符，取得共享内存标识符后，通过`shmat`将这个内存区映射到本进程的虚拟地址空间



### 消息队列

消息队列是一个消息的链表，**保存在内核中**

- 消息队列中的**每个消息都是一个数据块，具有特定的格式**
- 操作系统中可以存在多个消息队列，每个消息队列有唯一的`key`，称为消息队列标识符
  - 操作系统提供创建消息队列、取消息、发消息等系统调用
  - 操作系统负责**读写同步**
    - 若消息队列已满，则写消息进程排队等待
    - 若取消息进程没有找到需要的消息，则在等待队列中寻找
- 消息队列是**异步的**
  - 消息队列允许一个或多个进程向它写入和读取消息
  - 消息的发送者和接收者**不需要同时与消息队列交互**，消息会保存在队列中，直到接收者取消息

**优点**

消息队列克服了**信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限**等缺点

- 和信号相比，消息队列能够传递更多的信息
- 与管道相比
  - 消息队列提供了**有格式的数据**
  - 取消息进程**可以选择接收特定类型的消息**，而不像管道默认全部接收

**缺点**

- 消息队列仍然有大小限制
- 消息队列是**异步的**，所以接收者必须**轮询**消息队列才能收到最近的消息



### 套接字

**不同的计算机的进程**之间通过socket通信

- 也可用于同一台计算机的不同进程

- 需要通信的进程之间首先要**各自创建一个socket**，声明自己接收来自端口的数据
  - 内容包括主机地址与端口号（`ip:port`）
- 进程通过socket把消息发送到网络层中，网络层通过主机地址将其发到目的主机，**目的主机通过端口号发给对应进程**

- 操作系统提供创建socket、发送、接收的系统调用
  - 为每个socket设置**发送缓冲区**，**接收缓冲区**

## 进程调度

**批处理系统**

- 先来先服务：first-come first-serverd（FCFS）
  - 非抢占式，开销小，无饥饿问题

- 短作业优先：shortest job first（SJF）
  - 非抢占式，开销可能较大，可能导致饥饿问题

- 最短剩余时间优先：shortest remaining time next（SRTN）
  - 短作业优先的抢占式版本
- 最高响应比优先：Highest Response Ratio Next（HRRN）

**交互式系统**

- 时间片轮转：Round Robin
  - 抢占式，开销小，无饥饿问题
- 优先级调度算法：Priority
- 多级反馈队列调度算法：Multilevel Feedback Queue

## 进程分类

- 僵尸进程：停止运行
- 孤儿进程：正在运行
- 守护进程：正在运行

### 僵尸进程

僵尸进程是指**终止但还未被回收**的进程

- 当一个进程由于某种原因终止时，**内核并不是立即把它从系统中清除**。
- 进程会保持在一种**已终止**的状态中，直到被它的**父进程回收**。当父进程回收已终止的子进程时，内核会抛弃已终止的进程，此时该进程就不存在了
- 如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()` 来回收，那么就会产生僵尸进程
- 僵尸进程是一个已经死亡的进程，但是其**进程描述符**仍然保存在系统的进程表中
- 如果杀死父进程，僵尸进程就会变成孤儿进程，由`Init`进程接管并处理

**危害**

- 占用进程号
  - 系统所能使用的进程号是有限的，可能导致不能产生新的进程
- 占用一定的内存

### 孤儿进程

如果某个进程的**父进程先结束了**，那么它的子进程会成为孤儿进程

- 每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用`Init`进程（`pid = 1`）接管，并由`Init`进程调用 `wait` 等待其结束，完成状态收集工作。
- **孤儿进程不会对系统造成危害**

### 守护进程

守护进程：daemon

- 一种**在后台执行**的电脑程序，此类程序会被以进程的形式初始化



## 锁

Java中的锁类型

- 公平锁/非公平锁
- 可重入锁
- 独享锁/共享锁
- 互斥锁/读写锁
- 乐观锁/悲观锁
- 分段锁
- 偏向锁/轻量级锁/重量级锁
- 自旋锁

### 自旋锁

`Spinlock`

**自旋**：持续观察一个变量直到它发生改变的过程

**自旋锁**：一个线程在获取锁的时候，如果锁已经被其它线程获取，那么**该线程将循环等待，然后不断的判断锁是否能够被成功获取**，直到获取到锁才会退出循环

自旋锁通过一个**忙标志**`flag`表示锁是否被占用

- 当`flag = 0`时表示锁空闲
- 当一个线程成功将`flag`从`0`变为`1`时，表示该线程获得锁
  - 线程在 `while` 循环中尝试通过TAS（Test And Set）等硬件**原子指令**获取锁

**优点**

- 不会使线程状态发生切换，这就避免了操作系统**重新调度**和**上下文切换**的开销
  - 操作系统内核经常使用自旋锁

> 自旋锁的性能在**多处理器**的场景下性能要比单处理器更好（假设线程均匀分布在多个 CPU 上）
>
> - 因为如果当前线程持有锁并很快释放，那么其他线程很可能在自旋的时候就能直接获取到这个锁，这样不会浪费整个时钟周期

**缺点**

- 在单处理器的场景下，如果锁已经被另一个线程持有，那么当前线程**在尝试加锁时需要将整个时间片空转完**，除非发生上下文切换，否则它是不可能获取到锁的
- 自旋锁可能会导致**饥饿**

因此，自旋锁适用于线程**持有锁的时间很短**的场景。线程持有锁的时间越长，则持有锁的线程被 OS 调度程序中断的风险越大，其他线程空转浪费时间片的概率也越大。





## 互斥锁

 `Mutex`

互斥锁需要操作系统的帮助。当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。

互斥锁的开销主要体现在线程的**重新调度**和**上下文切换**上，获取锁的开销是比较大的。因此 mutex 适用于线程**持有锁时间比较长**的场景。

如果线程持有锁的时间比较短，使用 mutex 会因为频繁的线程切换而导致效率变差。设想一个极端场景：假设现在有 100 个线程，线程 1 持有锁。此时切换到下一个线程，后者会因为无法获取锁而休眠，这样很有可能线程 2 ～ 100 都陷入休眠。这时又切换回线程 1，线程 1 很快就释放了锁，于是又唤醒一个新的线程。这样一番折腾下来，大部分时间都花在了用户态到内核态的切换（系统调用）、重新调度（移到阻塞队列）和上下文切换（线程切换）上了，还不如使用自旋锁的效率高。

## IO模型

### 
