# Java

## native方法

`native`关键字修饰

- 说明这个方法是个原生函数，不是用java语言实现的，是使用c/c++实现的

- 被编译成了DLL，由java去调用，jdk源码中不包含
- 对于不同的平台它们是不同的，java在不同的操作系统中调用不同的`native`方法实现对操作系统的访问，
  - 因为java没有指针，不能直接访问操作系统底层

**调用过程**

1. 在java中声明`native`方法，然后编译
2. 用`javah`产生一个 `.h` 文件
3. 写一个 `.cpp`文件实现`native`方法
   1. 需要包含第二步产生的`.h`文件
   2. 需要包含了jdk带的jni.h文件
4. 将`.cpp`文件编译成动态链接库文件
5. 在java中用`System.loadLibrary()`文件加载动态链接库文件

这个`navite`方法就可被访问了

## 集合

### 重写`hashCode()`和`equals()`

`Collection`接口：对象所在类需要重写`equals()`方法

- `contains(Object obj)`：调用对象所在类的`equals`方法来判断集合中每一个元素是否是目标元素
- `remove(Object obj)` ：调用对象所在类的`equals`方法判断是否是要删除的那个元素，只会删除匹配的第一个元素



`Set`接口：对象所在类要重写`equals()`和`hashCode()`方法，以实现对象相等规则（相等的对象必须具有相等的散列码）

- `Map`中的`key`使用`Set`存储，所以`key`所在类必须重写`hashCode()`和`equals()`方法



**hashcode()**找位置，**equals()**判断位置上的元素

1. `HashSet`调用要添加**对象所在类**的`hashCode()`方法来得到该对象的hashCode值
2. 散列函数根据对象的hashCode值决定它在`HashSet`底层数组中的**存储位置**
   1. 散列函数会利用**底层数组的长度**计算得到对象在数组中的下标
   2. **散列函数计算会尽可能保证能均匀存储**，越是散列分布，该散列函数设计的越好
3. 如果该存储位置上**没有其他对象，则添加该对象**
4. 如果该存储位置上有其他对象，则需要比较两个对象的hashCode值
   1. 如果两个对象的**hashCode值不相等，则通过链表的方式添加该对象**
   2. 如果两个对象的hashCode值相等，再调用`equals()`方法
      1. 如果`equals()`方法结果为`true`，则添加失败
      2. 如果`equals()`方法结果为`false`，**则通过链表的方式添加该对象**

> 以链表的形式在同一个位置上存放多个元素会使得`HashSet`的性能降低，因为不能快速定位了



重写`hashCode()`方法

- 对同一个对象多次调用`hashCode()`方法应该返回相同的值
- 当两个对象的`equals()`方法比较返回true 时，两个对象的`hashCode()`方法的返回值也应相等
- 对象中用作`equals()`方法比较的属性，都应该用来计算hashCode值

> 所以重写了`equals()`方法也要重写`hashCode()`方法
>
> IDEA中在自定义类调用工具自动重写`equals()`和`hashCode()`方法时默认使用31
>
> - 31只占用5bits，相乘造成数据溢出的概率较小
> - 31可以由i*31== (i<<5)-1来表示，现在很多虚拟机里面都有做相关优化（提高算法效率）
> - 31是一个素数，一个数字乘以素数的最终结果只能被素数本身和被乘数还有1来整除（减少冲突）
> - 选择系数的时候要选择尽量大的系数，因为计算出来的hash地址越大，冲突就越少，查找起来效率也会提高





## Java虚拟机

Java内存区域

1. 介绍下Java内存区域（运行时数据区）

2. 对象的访问定位的两种方式

Java内存回收

1. 如何判断对象是否死亡（两种方法）。

2. 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。

3. 垃圾收集有哪些算法，各自的特点？

4. HotSpot为什么要分为新生代和老年代？

5. 常见的垃圾回收器有那些？

6. 介绍一下CMS,G1收集器。

7. Minor Gc和Full GC 有什么不同呢？

类加载机制

1. 简单说说类加载过程，里面执行了哪些操作？

2. 对类加载器有了解吗？

3. 什么是双亲委派模型？

4. 双亲委派模型的工作过程以及使用它的好处。

类文件结构

- 介绍一下Class类文件结构
- 常量池主要存放的是那两大常量？
- Class文件的继承关系是如何确定的？
- 字段表、方法表、属性表主要包含那些信息？

 

## 多线程

### 线程创建

1. 继承`Thread`类
2. 实现`Runnable`接口
3. 实现`Callable`接口

> 重写`run()`方法：**线程体**

**比较**

推荐使用`Runnable`接口

- 避免单继承局限性
- 方便同一个对象被多个线程共享使用
  - 适合多个相同线程来处理同一份资源

### 线程启动

通过`start()`方法启动线程

- Java的线程是不允许启动两次的，一个线程对象只能调用一次`start()`方法启动
  - 重复调用抛出异常（运行时异常）
- 直接调用`run()`无法开启一个新线程
  - `run()`方法只是一个类中的普通方法，直接执行和普通的方法没区别，`start()`方法首先做了创建线程等一系列工作，然后调用`run()`方法
  - 即`start()`方法是在一个新的线程上面去调用`run()`方法，`run()`方法则是在调用`run()`方法的当前的线程当中执行

#### 静态代理

StaticProxy：`new Thread(Runnable).start();`

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实对象

**优点**

- 真实对象专注于自己的工作
- 代理对象可以做真实对象做不了的工作

### 线程状态

1. 创建（`NEW`）
   1. 当一个`Thread`类或其子类的对象被**声明并创建**时，新生的线程对象处于创建状态
   1. 还没有调用`start()`方法
2. 就绪（`RUNNABLE`）
   1. 处于创建状态的线程被`start()`后将进入线程队列等待CPU时间片
   2. 此时它已具备了运行的条件，只是没分配到CPU资源
3. 运行（`RUNNING`）
   1. 当就绪的线程被调度并获得CPU资源时就进入运行状态
   2. `run()`方法定义了线程的操作和功能
4. 阻塞（`BLOCKED`）
   1. 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
5. 死亡（`DEAD`）
   1. 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束
   2. 结束后的线程不能再次启动



### 线程池

`ThreadPool`：并发框架

**优点**

1. 降低资源消耗。 通过重复利用已经创建的线程降低线程创建的和销毁造成的消耗。例如，工作线程Woker会无线循环获取阻塞队列中的任务来执行。
2. 提高响应速度。 当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。 线程是稀缺资源，Java的线程池可以对线程资源进行统一分配、调优和监控。



# 计算机网络

## TCP



# 操作系统

## 并行与并发

- 并行：parallelism
  - 多个处理器或者多核处理器**同时**处理多个不同的任务
- 并发：concurrency
  - 通过调度算法，一个处理器同时处理多个任务

## 进程和线程

`Process`和`Thread`

- 进程是系统进行**资源分配**的基本单位，线程是**CPU调度**的基本单位
- 线程依赖于进程而存在，一个进程至少有一个线程
- 进程有自己的独立地址空间，**线程共享所属进程的地址空间**
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器PC，寄存器reg和栈），和其他线程共享本进程的相关资源（如内存、I/O、cpu等）
- 在进程切换时，涉及到整个**当前进程CPU环境**的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作
  - **进程切换的开销远大于线程切换的开销**
- 线程之间的通信更方便，同一进程下的线程**共享全局变量等数据**，而进程之间的通信需要以进程间通信（IPC）的方式进行
- **多线程程序**只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为**进程有自己的独立地址空间**
  - 多进程更加健壮

## 进程通信

- 共享内存
- 消息队列
- 管道（Pipe）
- 命名管道
- 信号（Signal）
- 信号量
- 套接字（Socket）

### 信号

信号是Linux系统**响应某些条件而产生的一个事件**

- 由操作系统事先定义，接收到该信号的进程可以采取自定义的行为
- 这是一种**订阅-发布**的模式

**信号来源**

- 硬件来源：如按下`CTRL+C`、除0、非法内存访问等
- 软件来源：如`kill`命令、Alarm Clock超时、当Reader中止之后又向管道写数据等

> `kill -9`

**一般的信号是都是由一个错误产生的**

- 除数为0时会引发0号中断，即除零异常，这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT中的中断处理程序

- 操作系统**处理这个异常的方法就是向进程发送一个信号** `SIGFPE`。如果进程设置了相应的signal handler，就执行进程的处理方法。否则就执行操作系统的默认操作（一般这种信号的默认操作是杀死进程）

> 操作系统会**将这些硬件异常包装成信号发送给进程**，如果进程不处理这几个异常信号，默认的行为就是挂掉

**进程发送信号**

- 操作系统提供发送信号的**系统调用**
- 系统调用会**将信号放到目标进程的信号队列中**
  - 如果目标进程未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。
  - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程
- 发送信号时，必须指明发送的目标进程的PID
  - 一般用在具有**亲缘关系的进程之间**

**进程接收信号**

- 每个进程有一个信号队列，存放**其他进程发送给它，等待它处理的信号**
- 进程在执行过程中的**特定时刻检查并处理自己的信号队列**
  - 如从系统空间返回到用户空间之前

**用户进程对信号的处理**

- 处理信号

  - 定义**信号处理函数**，当信号发生时执行相应的处理函数

- 忽略信号

  - 当不希望接收到的信号对进程的执行产生影响时，可以忽略该信号，不对信号进程作任何处理，从而让进程继续执行时

- 不处理也不忽略

  - 执行默认操作，linux系统对每种信号都规定了默认操作

  - 有些信号用户进程是无法处理也无法忽略的（如`SIGSTOP`、`SIGKILL` 等）
